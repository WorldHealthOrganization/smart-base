# This is a simple workflow that runs the publisher and copies the output to https://<owner>.github.io/<repo>/index.html
# Based on the idea by Carl Leitner
# Change log:
# 2021-06-18: (JCT): publish default branches to / , other branches branches/<branch>
# 2021-11-26: (JCT): Reusable workflow
# 2022-01-28: (JCT): add auto-create gh-pages if it doesn't exist
# 2023-01-22: (JCT): use checkout action v3, and JamesIves/github-pages-deploy-action@v4


# Make sure your repo has a branch called gh-pages

name: CI

# Controls when the action will run. 
on: 
  workflow_call: # Reusable by other workflows
    inputs:
      tx:
        required: false
        type: string
  # This is a called workflow - it should not trigger directly on push/pull_request
  # The main ghbuild.yml wrapper calls this workflow

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      tx:
        description: 'Optional Custom terminology server URL'
        required: false

# Prevent concurrent deployments to avoid race conditions when updating gh-pages branch
concurrency:
  group: gh-pages-deployment-${{ github.ref }}
  cancel-in-progress: false

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      # id-token: write
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get branch name
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BRANCH_NAME="${{ github.head_ref }}"
          else
            BRANCH_NAME="${GITHUB_REF##*/}"
          fi
          
          # Validate that branch name is not empty
          if [ -z "$BRANCH_NAME" ]; then
            echo "âŒ Error: Branch name is empty or could not be determined"
            echo "Event: ${{ github.event_name }}"
            echo "GITHUB_REF: ${GITHUB_REF:-'(not set)'}"
            echo "github.head_ref: ${{ github.head_ref }}"
            exit 1
          fi
          
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          # Sanitize branch name for URLs and file paths
          SANITIZED_BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          
          # Validate that sanitized branch name is not empty
          if [ -z "$SANITIZED_BRANCH_NAME" ]; then
            echo "âŒ Error: Sanitized branch name is empty after processing"
            echo "Original branch name: $BRANCH_NAME"
            exit 1
          fi
          
          echo "SANITIZED_BRANCH_NAME=$SANITIZED_BRANCH_NAME" >> $GITHUB_ENV

      - name: Echo branch name and check if it's the default branch
        run: |
          echo "ðŸ”¨ Building branch: $BRANCH_NAME"
          DEFAULT_BRANCH=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')
          echo "Default Branch: $DEFAULT_BRANCH"
          if [ "$BRANCH_NAME" == "$DEFAULT_BRANCH" ]; then
            echo "This is the default branch."
            echo "IS_DEFAULT_BRANCH=true" >> $GITHUB_ENV
            echo "DEPLOY_URL=https://worldhealthorganization.github.io/${{ github.event.repository.name }}" >> $GITHUB_ENV
          else
            echo "This is NOT the default branch."
            echo "IS_DEFAULT_BRANCH=false" >> $GITHUB_ENV
            echo "DEPLOY_URL=https://worldhealthorganization.github.io/${{ github.event.repository.name }}/branches/$SANITIZED_BRANCH_NAME" >> $GITHUB_ENV
          fi

      - name: Create gh-pages branch if it doesn't exist
        run: |
          git fetch origin
          # Check if gh-pages branch exists remotely
          if git ls-remote --exit-code --heads origin gh-pages > /dev/null 2>&1; then
            echo 'gh-pages branch exists remotely';
          else
            echo 'gh-pages branch does not exist, creating it';
            git checkout --orphan gh-pages
            git reset --hard
            git commit --allow-empty -m "Initializing gh-pages branch"
            git push origin gh-pages
            git checkout $BRANCH_NAME
          fi

      - name: Update the image to the latest publisher
        uses: docker://hl7fhir/ig-publisher-base:latest
        with:
          # Get the latest publisher - don't run the batch script but run the line directly
          args: curl -L https://github.com/HL7/fhir-ig-publisher/releases/latest/download/publisher.jar -o ./input-cache/publisher.jar --create-dirs


      - name: Create package cache folder
        uses: docker://hl7fhir/ig-publisher-base:latest
        with:
          entrypoint: /bin/sh
          args: -c "mkdir -p ./fhir-package-cache && chown 1001:127 ./fhir-package-cache"

      - name: Run the IG publisher
        uses: docker://hl7fhir/ig-publisher-base:latest
        with:
          entrypoint: /bin/sh
          args: -c "mkdir -p /var/lib/.fhir && chown $(id -u):$(id -g) /var/lib/.fhir"

      - name: Run the IG publisher with optional tx
        run: |
          echo "TX input: ${{ inputs.tx }}"

          CMD="java -Xmx6g -jar ./input-cache/publisher.jar publisher \
            -ig . \
            -auto-ig-build \
            -repo https://github.com/${GITHUB_REPOSITORY}/tree/${GITHUB_REF_NAME} \
            -package-cache-folder ./fhir-package-cache"

          if [ ! -z "${{ inputs.tx }}" ]; then
            CMD="$CMD -tx ${{ inputs.tx }}"
          fi

          echo "Running command: $CMD"
          
          docker run --rm \
            -v ${{ github.workspace }}:/work \
            -w /work \
            hl7fhir/ig-publisher-base:latest \
            sh -c "$CMD"
     
      # Additional step to upload qa.json as an artifact
      - name: Upload qa.json artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: qa-json-artifact
          path: ./output/qa.json  # Adjust the path based on where qa.json is located

      # Post-process DAK API documentation after IG publisher runs
      - name: Generate DAK API Documentation
        run: |
          echo "Post-processing DAK API documentation..."
          
          # Install Python dependencies for DAK scripts
          pip install pyyaml
          
          # Check if there are schemas or content to document
          HAVE_CONTENT=false
          
          # Check for expansions.json (needed for ValueSet schemas)
          if [ -f "./output/expansions.json" ]; then
            echo "Found expansions.json, generating ValueSet schemas..."
            if [ -f "./input/scripts/generate_valueset_schemas.py" ]; then
              python3 input/scripts/generate_valueset_schemas.py
              HAVE_CONTENT=true
            else
              echo "ValueSet schema generator not found, skipping"
            fi
          fi
          
          # Check for StructureDefinition files (needed for Logical Model schemas)  
          if find ./output -name "StructureDefinition-*.json" -print -quit | grep -q .; then
            echo "Found StructureDefinition files, generating Logical Model schemas..."
            if [ -f "./input/scripts/generate_logical_model_schemas.py" ]; then
              python3 input/scripts/generate_logical_model_schemas.py
              HAVE_CONTENT=true
            else
              echo "Logical Model schema generator not found, skipping"
            fi
          fi
          
          # Check if there are any schemas or OpenAPI files to document
          if [ -f "./output/ValueSets.schema.json" ] || [ -f "./output/LogicalModels.schema.json" ] || \
             find ./output -name "ValueSet-*.schema.json" -print -quit | grep -q . || \
             find ./output -name "*Model*.schema.json" -print -quit | grep -q . || \
             [ -d "./input/images/openapi" ] && find ./input/images/openapi -name "*.json" -o -name "*.yaml" -o -name "*.yml" | grep -q .; then
            HAVE_CONTENT=true
          fi
          
          # Generate DAK API documentation hub if we have content
          if [ "$HAVE_CONTENT" = true ]; then
            if [ -f "./input/scripts/generate_dak_api_hub.py" ]; then
              echo "Generating DAK API documentation hub..."
              python3 input/scripts/generate_dak_api_hub.py output
              echo "âœ… DAK API documentation generated successfully"
            else
              echo "DAK API hub generator not found, skipping"
            fi
          else
            echo "No schemas or OpenAPI files found to document, skipping DAK API generation"
          fi

      - name: Delete files >100MB before deployment
        run: |
          echo "Removing files over 100 MB from ./output..."
          find ./output -type f -size +100M -print -delete

      - name: Deploy candidate
        uses: JamesIves/github-pages-deploy-action@v4.4.2
        if: env.IS_DEFAULT_BRANCH == 'false'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: gh-pages # The branch the action should deploy to.
          folder: ./output # The folder the action should deploy.
          commit-message: Deploy candidate branch
          target-folder: branches/${{ env.SANITIZED_BRANCH_NAME }}
          single-commit: true
          clean: false 
          force: true 

      - name: Deploy main
        uses: JamesIves/github-pages-deploy-action@v4.4.2
        if: env.IS_DEFAULT_BRANCH == 'true'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: gh-pages # The branch the action should deploy to.
          folder: ./output # The folder the action should deploy.
          commit-message: Deploy main branch
          single-commit: true
          clean-exclude: |
            branches
            sitepreview
          force: true
