#!/usr/bin/env python3
"""
FHIR Logical Model JSON Schema Generator

This script processes FSH files containing FHIR Logical Model definitions
and generates JSON schemas for each Logical Model. It handles FHIR-specific 
features including ValueSet bindings and references to ValueSet schemas 
generated by the ValueSet schema generator.

The script is intended to be run after the IG publisher and ValueSet schema 
generation to create schemas that can be used for validation of data against 
the Logical Models.

Usage:
    python generate_logical_model_schemas.py [fsh_input_dir] [output_dir]

Author: SMART Guidelines Team
"""

import json
import os
import sys
import logging
import re
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path


def setup_logging() -> logging.Logger:
    """Configure logging for the script."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    return logging.getLogger(__name__)


class FSHParser:
    """Parser for FSH (FHIR Shorthand) files to extract Logical Model definitions."""
    
    def __init__(self, logger: logging.Logger):
        self.logger = logger
        
    def find_fsh_files(self, directory: str) -> List[str]:
        """Find all FSH files in the given directory."""
        fsh_files = []
        for root, dirs, files in os.walk(directory):
            for file in files:
                if file.endswith('.fsh'):
                    fsh_files.append(os.path.join(root, file))
        return fsh_files
    
    def parse_logical_models(self, fsh_files: List[str]) -> List[Dict[str, Any]]:
        """Parse logical models from FSH files."""
        logical_models = []
        
        for fsh_file in fsh_files:
            models = self.extract_logical_models_from_file(fsh_file)
            logical_models.extend(models)
            
        return logical_models
    
    def extract_logical_models_from_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Extract logical models from a single FSH file."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            self.logger.error(f"Error reading file {file_path}: {e}")
            return []
        
        models = []
        lines = content.split('\n')
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            # Look for logical model definition
            if line.startswith('Logical:'):
                model = self.parse_logical_model(lines, i, file_path)
                if model:
                    models.append(model)
                    self.logger.info(f"Found logical model: {model['name']} in {file_path}")
            i += 1
            
        return models
    
    def parse_logical_model(self, lines: List[str], start_index: int, file_path: str) -> Optional[Dict[str, Any]]:
        """Parse a single logical model definition starting at the given line."""
        model = {
            'name': '',
            'title': '',
            'description': '',
            'parent': '',
            'elements': [],
            'file_path': file_path
        }
        
        i = start_index
        
        # Parse header information
        while i < len(lines):
            line = lines[i].strip()
            
            if line.startswith('Logical:'):
                model['name'] = line.split(':', 1)[1].strip()
            elif line.startswith('Title:'):
                model['title'] = line.split(':', 1)[1].strip().strip('"')
            elif line.startswith('Description:'):
                model['description'] = line.split(':', 1)[1].strip().strip('"')
            elif line.startswith('Parent:'):
                model['parent'] = line.split(':', 1)[1].strip()
            elif line.startswith('*'):
                # Start of element definitions
                break
            i += 1
        
        # Parse element definitions
        current_element = None
        elements_by_name = {}
        
        while i < len(lines):
            line = lines[i].strip()
            
            if not line or line.startswith('//'):
                i += 1
                continue
                
            if line.startswith('*'):
                # Check if this is a ValueSet binding for a previous element
                if 'from' in line and not any(part in line for part in ['1..1', '0..1', '0..*', '1..*']):
                    # This is a ValueSet binding line - parse the element name
                    from_index = line.find('from')
                    element_part = line[1:from_index].strip()
                    vs_part = line[from_index + 4:].strip()
                    
                    # Extract element name and ValueSet name
                    element_name = element_part.strip()
                    valueset_name = vs_part.split()[0]
                    
                    # Find the element with this name and add the ValueSet
                    if element_name in elements_by_name:
                        elements_by_name[element_name]['valueset'] = valueset_name
                    
                    i += 1
                    continue
                
                # Parse new element
                element = self.parse_element(line)
                if element:
                    model['elements'].append(element)
                    elements_by_name[element['name']] = element
                    current_element = element
            elif line.startswith('Logical:'):
                # Start of new logical model
                break
            i += 1
        
        return model if model['name'] else None
    
    def parse_element(self, line: str) -> Optional[Dict[str, Any]]:
        """Parse an element definition line."""
        # Remove leading asterisk and whitespace
        line = line[1:].strip()
        
        # Skip metadata lines (starting with ^)
        if line.startswith('^'):
            return None
        
        # Pattern to match element definitions
        # Examples:
        # id 1..1 id "Requirement ID" "An identifier or code for the requirement"
        # activity 1..1 string "Activity" "Description of the activity being performed"
        # actor 0..* Reference(SGActor) "Actor" "The actor(s) that should fulfill the requirement"
        # capability[x] 0..1 string or Coding "Capability" "Capability achieved by an actor fulfilling the requirement (I want)"
        # type from SGPersonaTypesVS
        
        parts = line.split()
        if len(parts) < 3:
            return None
        
        element = {
            'name': parts[0],
            'cardinality': '',
            'type': '',
            'valueset': '',
            'short': '',
            'definition': ''
        }
        
        # Handle choice types like capability[x]
        if '[x]' in element['name']:
            element['name'] = element['name'].replace('[x]', '')
            element['choice'] = True
        else:
            element['choice'] = False
        
        # Check for ValueSet binding (pattern: "from ValueSetName")
        if 'from' in line:
            from_index = line.find('from')
            vs_part = line[from_index + 4:].strip()
            # Extract ValueSet name (stop at first space if there are quotes after)
            element['valueset'] = vs_part.split()[0]
            # Remove the "from" part to parse the rest
            line = line[:from_index].strip()
            parts = line.split()
        
        if len(parts) >= 2:
            element['cardinality'] = parts[1]
        
        # For choice types, we need to extract the full type including "or" parts
        if element['choice'] and len(parts) >= 3:
            # Find the start of quoted strings to know where type ends
            quote_start = line.find('"')
            if quote_start != -1:
                type_part = line[:quote_start].strip()
                # Extract everything after cardinality as the type
                type_parts = type_part.split()[2:]  # Skip name and cardinality
                element['type'] = ' '.join(type_parts)
            else:
                # No quotes, take everything after cardinality
                element['type'] = ' '.join(parts[2:])
        elif len(parts) >= 3:
            element['type'] = parts[2]
        
        # Extract quoted strings for short and definition
        quotes = re.findall(r'"([^"]*)"', line)
        if len(quotes) >= 1:
            element['short'] = quotes[0]
        if len(quotes) >= 2:
            element['definition'] = quotes[1]
        
        return element


class SchemaGenerator:
    """Generates JSON schemas from parsed logical models."""
    
    def __init__(self, logger: logging.Logger, canonical_base: str = "http://smart.who.int/base"):
        self.logger = logger
        self.canonical_base = canonical_base
        
        # FHIR datatype to JSON Schema type mapping
        self.type_mapping = {
            'string': {'type': 'string'},
            'boolean': {'type': 'boolean'},
            'integer': {'type': 'integer'},
            'decimal': {'type': 'number'},
            'date': {'type': 'string', 'format': 'date'},
            'dateTime': {'type': 'string', 'format': 'date-time'},
            'time': {'type': 'string', 'format': 'time'},
            'instant': {'type': 'string', 'format': 'date-time'},
            'uri': {'type': 'string', 'format': 'uri'},
            'url': {'type': 'string', 'format': 'uri'},
            'canonical': {'type': 'string', 'format': 'uri'},
            'oid': {'type': 'string'},
            'id': {'type': 'string'},
            'code': {'type': 'string'},
            'uuid': {'type': 'string', 'format': 'uuid'},
            'base64Binary': {'type': 'string'},
            'markdown': {'type': 'string'},
            'unsignedInt': {'type': 'integer', 'minimum': 0},
            'positiveInt': {'type': 'integer', 'minimum': 1},
            
            # Complex types
            'Coding': {'type': 'object'},
            'CodeableConcept': {'type': 'object'},
            'Identifier': {'type': 'object'},
            'Quantity': {'type': 'object'},
            'Range': {'type': 'object'},
            'Period': {'type': 'object'},
            'Attachment': {'type': 'object'},
            'ContactPoint': {'type': 'object'},
            'HumanName': {'type': 'object'},
            'Address': {'type': 'object'},
        }
    
    def generate_schema(self, logical_model: Dict[str, Any]) -> Dict[str, Any]:
        """Generate JSON schema for a logical model."""
        schema_id = f"{self.canonical_base}/StructureDefinition/{logical_model['name']}.schema.json"
        
        schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "$id": schema_id,
            "title": logical_model.get('title', logical_model['name']),
            "description": logical_model.get('description', f"JSON Schema for {logical_model['name']} Logical Model. Generated from FSH definition."),
            "type": "object",
            "properties": {},
            "required": []
        }
        
        # Add metadata
        schema["fhir:logicalModel"] = f"{self.canonical_base}/StructureDefinition/{logical_model['name']}"
        if logical_model.get('parent'):
            schema["fhir:parent"] = logical_model['parent']
        
        # Process elements
        for element in logical_model['elements']:
            self.add_element_to_schema(schema, element)
        
        return schema
    
    def add_element_to_schema(self, schema: Dict[str, Any], element: Dict[str, Any]):
        """Add an element to the JSON schema."""
        element_name = element['name']
        cardinality = element['cardinality']
        element_type = element['type']
        valueset = element['valueset']
        
        # Determine if element is required
        if cardinality and cardinality.startswith('1'):
            schema['required'].append(element_name)
        
        # Handle choice types
        if element.get('choice', False):
            # For choice types, we'll create a more generic schema
            element_schema = {"oneOf": []}
            
            # Parse "or" separated types if present
            if ' or ' in element_type:
                types = [t.strip() for t in element_type.split(' or ')]
                for type_option in types:
                    type_schema = self.get_type_schema(type_option, valueset)
                    if type_schema:
                        element_schema["oneOf"].append(type_schema)
            else:
                type_schema = self.get_type_schema(element_type, valueset)
                if type_schema:
                    element_schema = type_schema
                    
            # If we only have one type, simplify
            if len(element_schema.get("oneOf", [])) == 1:
                element_schema = element_schema["oneOf"][0]
        else:
            # Regular element
            element_schema = self.get_type_schema(element_type, valueset)
        
        # Handle cardinality for arrays
        if cardinality and ('*' in cardinality or cardinality.endswith('..n')):
            element_schema = {
                "type": "array",
                "items": element_schema
            }
            
            # Set minimum items based on cardinality
            if cardinality.startswith('1'):
                element_schema["minItems"] = 1
        
        # Add description if available
        if element.get('definition'):
            element_schema["description"] = element['definition']
        elif element.get('short'):
            element_schema["description"] = element['short']
        
        schema['properties'][element_name] = element_schema
    
    def get_type_schema(self, fhir_type: str, valueset: str = '') -> Dict[str, Any]:
        """Get JSON schema for a FHIR type."""
        # Handle Reference types
        if fhir_type.startswith('Reference('):
            return {
                "type": "object",
                "description": f"Reference to {fhir_type}"
            }
        
        # Handle ValueSet bindings
        if valueset:
            if fhir_type == 'code':
                # Reference the ValueSet schema
                return {
                    "$ref": f"ValueSet-{valueset}.schema.json"
                }
            elif fhir_type in ['Coding', 'CodeableConcept']:
                # For Coding/CodeableConcept type with ValueSet, we might want to be more specific
                return {
                    "type": "object",
                    "description": f"{fhir_type} from ValueSet {valueset}",
                    "properties": {
                        "system": {"type": "string"},
                        "code": {"$ref": f"ValueSet-{valueset}.schema.json"},
                        "display": {"type": "string"}
                    }
                }
        
        # Use type mapping
        if fhir_type in self.type_mapping:
            return self.type_mapping[fhir_type].copy()
        
        # Default for unknown types
        return {
            "type": "object",
            "description": f"FHIR {fhir_type}"
        }
    
    def save_schema(self, schema: Dict[str, Any], output_dir: str, model_name: str) -> Optional[str]:
        """Save a JSON schema to a file."""
        try:
            # Ensure output directory exists
            Path(output_dir).mkdir(parents=True, exist_ok=True)
            
            # Create filename
            filename = f"{model_name}.schema.json"
            filepath = os.path.join(output_dir, filename)
            
            # Save schema
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(schema, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Saved schema for Logical Model {model_name} to {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"Error saving schema for Logical Model {model_name}: {e}")
            return None


def process_logical_models(fsh_input_dir: str, output_dir: str) -> int:
    """Process FSH files and generate JSON schemas for logical models."""
    logger = logging.getLogger(__name__)
    
    # Initialize parser and generator
    parser = FSHParser(logger)
    generator = SchemaGenerator(logger)
    
    # Find FSH files
    fsh_files = parser.find_fsh_files(fsh_input_dir)
    logger.info(f"Found {len(fsh_files)} FSH files to process")
    
    # Parse logical models
    logical_models = parser.parse_logical_models(fsh_files)
    logger.info(f"Found {len(logical_models)} logical models")
    
    # Generate schemas
    schemas_generated = 0
    schema_files = []
    
    for model in logical_models:
        logger.info(f"Generating schema for logical model: {model['name']}")
        
        # Generate schema
        schema = generator.generate_schema(model)
        
        # Save schema
        schema_path = generator.save_schema(schema, output_dir, model['name'])
        if schema_path:
            schemas_generated += 1
            schema_files.append(schema_path)
    
    logger.info(f"Generated {schemas_generated} Logical Model schemas")
    return schemas_generated


def main():
    """Main entry point for the script."""
    logger = setup_logging()
    
    # Parse command line arguments
    if len(sys.argv) > 2:
        fsh_input_dir = sys.argv[1]
        output_dir = sys.argv[2]
    elif len(sys.argv) > 1:
        fsh_input_dir = sys.argv[1]
        output_dir = "output"
    else:
        fsh_input_dir = "input/fsh"
        output_dir = "output"
    
    logger.info(f"Processing FSH files from: {fsh_input_dir}")
    logger.info(f"Output directory: {output_dir}")
    
    # Check if input directory exists
    if not os.path.exists(fsh_input_dir):
        logger.error(f"Input directory does not exist: {fsh_input_dir}")
        sys.exit(1)
    
    # Process logical models
    try:
        schemas_generated = process_logical_models(fsh_input_dir, output_dir)
        
        if schemas_generated > 0:
            logger.info(f"Successfully generated {schemas_generated} logical model schemas")
            sys.exit(0)
        else:
            logger.warning("No logical model schemas were generated")
            sys.exit(1)
            
    except Exception as e:
        logger.error(f"Error processing logical models: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()